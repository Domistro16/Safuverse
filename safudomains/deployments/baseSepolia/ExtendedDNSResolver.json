{
  "address": "0x0783bEebdCb97A43424B66875fdBe84cb551327D",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "addr",
          "type": "bytes"
        }
      ],
      "name": "InvalidAddressFormat",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotImplemented",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "context",
          "type": "bytes"
        }
      ],
      "name": "resolve",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x1f4152a7f9e19ea55a12ddc1830118e4bd38c6329858dce3b2272570b826a206",
  "receipt": {
    "to": null,
    "from": "0xD83deFbA240568040b39bb2C8B4DB7dB02d40593",
    "contractAddress": "0x0783bEebdCb97A43424B66875fdBe84cb551327D",
    "transactionIndex": 4,
    "gasUsed": "1070471",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x312c390a2e2c6dd8694e74e2025cb20d0f15982a64e41c2a402a9b7fef5bce19",
    "transactionHash": "0x1f4152a7f9e19ea55a12ddc1830118e4bd38c6329858dce3b2272570b826a206",
    "logs": [],
    "blockNumber": 37363877,
    "cumulativeGasUsed": "2054187",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "51c396074905eafbf23ffb9db0ffdf7f",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"addr\",\"type\":\"bytes\"}],\"name\":\"InvalidAddressFormat\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotImplemented\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Resolves names on ENS by interpreting record data stored in a DNS TXT record.      This resolver implements the IExtendedDNSResolver interface, meaning that when      a DNS name specifies it as the resolver via a TXT record, this resolver's      resolve() method is invoked, and is passed any additional information from that      text record. This resolver implements a simple text parser allowing a variety      of records to be specified in text, which will then be used to resolve the name      in ENS.      To use this, set a TXT record on your DNS name in the following format:          ENS1 <address or name of ExtendedDNSResolver> <record data>      For example:          ENS1 2.dnsname.ens.eth a[60]=0x1234...      The record data consists of a series of key=value pairs, separated by spaces. Keys      may have an optional argument in square brackets, and values may be either unquoted       - in which case they may not contain spaces - or single-quoted. Single quotes in      a quoted value may be backslash-escaped.                                       \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510                                       \\u2502 \\u250c\\u2500\\u2500\\u2500\\u2510  \\u2502        \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2524\\\" \\\"\\u2502\\u25c4\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510        \\u2502                                \\u2514\\u2500\\u2500\\u2500\\u2518                                           \\u2502        \\u2502  \\u250c\\u2500\\u2500\\u2500\\u2510    \\u250c\\u2500\\u2500\\u2500\\u2510    \\u250c\\u2500\\u2500\\u2500\\u2510    \\u250c\\u2500\\u2500\\u2500\\u2510    \\u250c\\u2500\\u2500\\u2500\\u2510    \\u250c\\u2500\\u2500\\u2500\\u2510    \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510    \\u250c\\u2500\\u2500\\u2500\\u2510 \\u2502      ^\\u2500\\u2534\\u2500\\u25ba\\u2502key\\u251c\\u2500\\u252c\\u2500\\u25ba\\u2502\\\"[\\\"\\u251c\\u2500\\u2500\\u2500\\u25ba\\u2502arg\\u251c\\u2500\\u2500\\u2500\\u25ba\\u2502\\\"]\\\"\\u251c\\u2500\\u252c\\u2500\\u25ba\\u2502\\\"=\\\"\\u251c\\u2500\\u252c\\u2500\\u25ba\\u2502\\\"'\\\"\\u251c\\u2500\\u2500\\u2500\\u25ba\\u2502quoted_value\\u251c\\u2500\\u2500\\u2500\\u25ba\\u2502\\\"'\\\"\\u251c\\u2500\\u253c\\u2500$           \\u2514\\u2500\\u2500\\u2500\\u2518 \\u2502  \\u2514\\u2500\\u2500\\u2500\\u2518    \\u2514\\u2500\\u2500\\u2500\\u2518    \\u2514\\u2500\\u2500\\u2500\\u2518 \\u2502  \\u2514\\u2500\\u2500\\u2500\\u2518 \\u2502  \\u2514\\u2500\\u2500\\u2500\\u2518    \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518    \\u2514\\u2500\\u2500\\u2500\\u2518 \\u2502                 \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518        \\u2502          \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510         \\u2502                                                     \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u25ba\\u2502unquoted_value\\u251c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518                                                                \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518      Record types:       - a[<coinType>] - Specifies how an `addr()` request should be resolved for the specified         `coinType`. Ethereum has `coinType` 60. The value must be 0x-prefixed hexadecimal, and will         be returned unmodified; this means that non-EVM addresses will need to be translated         into binary format and then encoded in hex.         Examples:          - a[60]=0xFe89cc7aBB2C4183683ab71653C4cdc9B02D44b7          - a[0]=0x00149010587f8364b964fcaa70687216b53bd2cbd798       - a[e<chainId>] - Specifies how an `addr()` request should be resolved for the specified         `chainId`. The value must be 0x-prefixed hexadecimal. When encoding an address for an         EVM-based cryptocurrency that uses a chainId instead of a coinType, this syntax *must*         be used in place of the coin type - eg, Optimism is `a[e10]`, not `a[2147483658]`.         A list of supported cryptocurrencies for both syntaxes can be found here:           https://github.com/ensdomains/address-encoder/blob/master/docs/supported-cryptocurrencies.md         Example:          - a[e10]=0xFe89cc7aBB2C4183683ab71653C4cdc9B02D44b7       - t[<key>] - Specifies how a `text()` request should be resolved for the specified `key`.         Examples:          - t[com.twitter]=nicksdjohnson          - t[url]='https://ens.domains/'          - t[note]='I\\\\'m great'\",\"kind\":\"dev\",\"methods\":{\"supportsInterface(bytes4)\":{\"details\":\"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/resolvers/profiles/ExtendedDNSResolver.sol\":\"ExtendedDNSResolver\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant alphabet = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = alphabet[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n}\\n\",\"keccak256\":\"0x456e9b3a2bfe189b5249857f624f4139e59331db518483b456c4e587a20552e0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xa28007762d9da9db878dd421960c8cb9a10471f47ab5c1b3309bfe48e9e79ff4\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/ExtendedDNSResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\nimport \\\"../../resolvers/profiles/IExtendedDNSResolver.sol\\\";\\r\\nimport \\\"../../resolvers/profiles/IAddressResolver.sol\\\";\\r\\nimport \\\"../../resolvers/profiles/IAddrResolver.sol\\\";\\r\\nimport \\\"../../resolvers/profiles/ITextResolver.sol\\\";\\r\\nimport \\\"../../utils/HexUtils.sol\\\";\\r\\nimport \\\"../../utils/BytesUtils.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Resolves names on ENS by interpreting record data stored in a DNS TXT record.\\r\\n *      This resolver implements the IExtendedDNSResolver interface, meaning that when\\r\\n *      a DNS name specifies it as the resolver via a TXT record, this resolver's\\r\\n *      resolve() method is invoked, and is passed any additional information from that\\r\\n *      text record. This resolver implements a simple text parser allowing a variety\\r\\n *      of records to be specified in text, which will then be used to resolve the name\\r\\n *      in ENS.\\r\\n *\\r\\n *      To use this, set a TXT record on your DNS name in the following format:\\r\\n *          ENS1 <address or name of ExtendedDNSResolver> <record data>\\r\\n *\\r\\n *      For example:\\r\\n *          ENS1 2.dnsname.ens.eth a[60]=0x1234...\\r\\n *\\r\\n *      The record data consists of a series of key=value pairs, separated by spaces. Keys\\r\\n *      may have an optional argument in square brackets, and values may be either unquoted\\r\\n *       - in which case they may not contain spaces - or single-quoted. Single quotes in\\r\\n *      a quoted value may be backslash-escaped.\\r\\n *\\r\\n *\\r\\n *                                       \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\r\\n *                                       \\u2502 \\u250c\\u2500\\u2500\\u2500\\u2510  \\u2502\\r\\n *        \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2524\\\" \\\"\\u2502\\u25c4\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\r\\n *        \\u2502                                \\u2514\\u2500\\u2500\\u2500\\u2518                                           \\u2502\\r\\n *        \\u2502  \\u250c\\u2500\\u2500\\u2500\\u2510    \\u250c\\u2500\\u2500\\u2500\\u2510    \\u250c\\u2500\\u2500\\u2500\\u2510    \\u250c\\u2500\\u2500\\u2500\\u2510    \\u250c\\u2500\\u2500\\u2500\\u2510    \\u250c\\u2500\\u2500\\u2500\\u2510    \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510    \\u250c\\u2500\\u2500\\u2500\\u2510 \\u2502\\r\\n *      ^\\u2500\\u2534\\u2500\\u25ba\\u2502key\\u251c\\u2500\\u252c\\u2500\\u25ba\\u2502\\\"[\\\"\\u251c\\u2500\\u2500\\u2500\\u25ba\\u2502arg\\u251c\\u2500\\u2500\\u2500\\u25ba\\u2502\\\"]\\\"\\u251c\\u2500\\u252c\\u2500\\u25ba\\u2502\\\"=\\\"\\u251c\\u2500\\u252c\\u2500\\u25ba\\u2502\\\"'\\\"\\u251c\\u2500\\u2500\\u2500\\u25ba\\u2502quoted_value\\u251c\\u2500\\u2500\\u2500\\u25ba\\u2502\\\"'\\\"\\u251c\\u2500\\u253c\\u2500$\\r\\n *           \\u2514\\u2500\\u2500\\u2500\\u2518 \\u2502  \\u2514\\u2500\\u2500\\u2500\\u2518    \\u2514\\u2500\\u2500\\u2500\\u2518    \\u2514\\u2500\\u2500\\u2500\\u2518 \\u2502  \\u2514\\u2500\\u2500\\u2500\\u2518 \\u2502  \\u2514\\u2500\\u2500\\u2500\\u2518    \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518    \\u2514\\u2500\\u2500\\u2500\\u2518 \\u2502\\r\\n *                 \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518        \\u2502          \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510         \\u2502\\r\\n *                                                     \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u25ba\\u2502unquoted_value\\u251c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\r\\n *                                                                \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\r\\n *\\r\\n *      Record types:\\r\\n *       - a[<coinType>] - Specifies how an `addr()` request should be resolved for the specified\\r\\n *         `coinType`. Ethereum has `coinType` 60. The value must be 0x-prefixed hexadecimal, and will\\r\\n *         be returned unmodified; this means that non-EVM addresses will need to be translated\\r\\n *         into binary format and then encoded in hex.\\r\\n *         Examples:\\r\\n *          - a[60]=0xFe89cc7aBB2C4183683ab71653C4cdc9B02D44b7\\r\\n *          - a[0]=0x00149010587f8364b964fcaa70687216b53bd2cbd798\\r\\n *       - a[e<chainId>] - Specifies how an `addr()` request should be resolved for the specified\\r\\n *         `chainId`. The value must be 0x-prefixed hexadecimal. When encoding an address for an\\r\\n *         EVM-based cryptocurrency that uses a chainId instead of a coinType, this syntax *must*\\r\\n *         be used in place of the coin type - eg, Optimism is `a[e10]`, not `a[2147483658]`.\\r\\n *         A list of supported cryptocurrencies for both syntaxes can be found here:\\r\\n *           https://github.com/ensdomains/address-encoder/blob/master/docs/supported-cryptocurrencies.md\\r\\n *         Example:\\r\\n *          - a[e10]=0xFe89cc7aBB2C4183683ab71653C4cdc9B02D44b7\\r\\n *       - t[<key>] - Specifies how a `text()` request should be resolved for the specified `key`.\\r\\n *         Examples:\\r\\n *          - t[com.twitter]=nicksdjohnson\\r\\n *          - t[url]='https://ens.domains/'\\r\\n *          - t[note]='I\\\\'m great'\\r\\n */\\r\\ncontract ExtendedDNSResolver is IExtendedDNSResolver, IERC165 {\\r\\n    using HexUtils for *;\\r\\n    using BytesUtils for *;\\r\\n    using Strings for *;\\r\\n\\r\\n    uint256 private constant COIN_TYPE_ETH = 60;\\r\\n\\r\\n    error NotImplemented();\\r\\n    error InvalidAddressFormat(bytes addr);\\r\\n\\r\\n    function supportsInterface(\\r\\n        bytes4 interfaceId\\r\\n    ) external view virtual override returns (bool) {\\r\\n        return interfaceId == type(IExtendedDNSResolver).interfaceId;\\r\\n    }\\r\\n\\r\\n    function resolve(\\r\\n        bytes calldata /* name */,\\r\\n        bytes calldata data,\\r\\n        bytes calldata context\\r\\n    ) external pure override returns (bytes memory) {\\r\\n        bytes4 selector = bytes4(data);\\r\\n        if (selector == IAddrResolver.addr.selector) {\\r\\n            return _resolveAddr(context);\\r\\n        } else if (selector == IAddressResolver.addr.selector) {\\r\\n            return _resolveAddress(data, context);\\r\\n        } else if (selector == ITextResolver.text.selector) {\\r\\n            return _resolveText(data, context);\\r\\n        }\\r\\n        revert NotImplemented();\\r\\n    }\\r\\n\\r\\n    function _resolveAddress(\\r\\n        bytes calldata data,\\r\\n        bytes calldata context\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        (, uint256 coinType) = abi.decode(data[4:], (bytes32, uint256));\\r\\n        bytes memory value;\\r\\n        // Per https://docs.ens.domains/ensip/11#specification\\r\\n        if (coinType & 0x80000000 != 0) {\\r\\n            value = _findValue(\\r\\n                context,\\r\\n                bytes.concat(\\r\\n                    \\\"a[e\\\",\\r\\n                    bytes((coinType & 0x7fffffff).toString()),\\r\\n                    \\\"]=\\\"\\r\\n                )\\r\\n            );\\r\\n        } else {\\r\\n            value = _findValue(\\r\\n                context,\\r\\n                bytes.concat(\\\"a[\\\", bytes(coinType.toString()), \\\"]=\\\")\\r\\n            );\\r\\n        }\\r\\n        if (value.length == 0) {\\r\\n            return value;\\r\\n        }\\r\\n        (address record, bool valid) = value.hexToAddress(2, value.length);\\r\\n        if (!valid) revert InvalidAddressFormat(value);\\r\\n        return abi.encode(record);\\r\\n    }\\r\\n\\r\\n    function _resolveAddr(\\r\\n        bytes calldata context\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        bytes memory value = _findValue(context, \\\"a[60]=\\\");\\r\\n        if (value.length == 0) {\\r\\n            return value;\\r\\n        }\\r\\n        (address record, bool valid) = value.hexToAddress(2, value.length);\\r\\n        if (!valid) revert InvalidAddressFormat(value);\\r\\n        return abi.encode(record);\\r\\n    }\\r\\n\\r\\n    function _resolveText(\\r\\n        bytes calldata data,\\r\\n        bytes calldata context\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        (, string memory key) = abi.decode(data[4:], (bytes32, string));\\r\\n        bytes memory value = _findValue(\\r\\n            context,\\r\\n            bytes.concat(\\\"t[\\\", bytes(key), \\\"]=\\\")\\r\\n        );\\r\\n        return abi.encode(value);\\r\\n    }\\r\\n\\r\\n    uint256 constant STATE_START = 0;\\r\\n    uint256 constant STATE_IGNORED_KEY = 1;\\r\\n    uint256 constant STATE_IGNORED_KEY_ARG = 2;\\r\\n    uint256 constant STATE_VALUE = 3;\\r\\n    uint256 constant STATE_QUOTED_VALUE = 4;\\r\\n    uint256 constant STATE_UNQUOTED_VALUE = 5;\\r\\n    uint256 constant STATE_IGNORED_VALUE = 6;\\r\\n    uint256 constant STATE_IGNORED_QUOTED_VALUE = 7;\\r\\n    uint256 constant STATE_IGNORED_UNQUOTED_VALUE = 8;\\r\\n\\r\\n    /**\\r\\n     * @dev Implements a DFA to parse the text record, looking for an entry\\r\\n     *      matching `key`.\\r\\n     * @param data The text record to parse.\\r\\n     * @param key The exact key to search for.\\r\\n     * @return value The value if found, or an empty string if `key` does not exist.\\r\\n     */\\r\\n    function _findValue(\\r\\n        bytes memory data,\\r\\n        bytes memory key\\r\\n    ) internal pure returns (bytes memory value) {\\r\\n        // Here we use a simple state machine to parse the text record. We\\r\\n        // process characters one at a time; each character can trigger a\\r\\n        // transition to a new state, or terminate the DFA and return a value.\\r\\n        // For states that expect to process a number of tokens, we use\\r\\n        // inner loops for efficiency reasons, to avoid the need to go\\r\\n        // through the outer loop and switch statement for every character.\\r\\n        uint256 state = STATE_START;\\r\\n        uint256 len = data.length;\\r\\n        for (uint256 i = 0; i < len; ) {\\r\\n            if (state == STATE_START) {\\r\\n                // Look for a matching key.\\r\\n                if (data.equals(i, key, 0, key.length)) {\\r\\n                    i += key.length;\\r\\n                    state = STATE_VALUE;\\r\\n                } else {\\r\\n                    state = STATE_IGNORED_KEY;\\r\\n                }\\r\\n            } else if (state == STATE_IGNORED_KEY) {\\r\\n                for (; i < len; i++) {\\r\\n                    if (data[i] == \\\"=\\\") {\\r\\n                        state = STATE_IGNORED_VALUE;\\r\\n                        i += 1;\\r\\n                        break;\\r\\n                    } else if (data[i] == \\\"[\\\") {\\r\\n                        state = STATE_IGNORED_KEY_ARG;\\r\\n                        i += 1;\\r\\n                        break;\\r\\n                    }\\r\\n                }\\r\\n            } else if (state == STATE_IGNORED_KEY_ARG) {\\r\\n                for (; i < len; i++) {\\r\\n                    if (data[i] == \\\"]\\\") {\\r\\n                        state = STATE_IGNORED_VALUE;\\r\\n                        i += 1;\\r\\n                        if (data[i] == \\\"=\\\") {\\r\\n                            i += 1;\\r\\n                        }\\r\\n                        break;\\r\\n                    }\\r\\n                }\\r\\n            } else if (state == STATE_VALUE) {\\r\\n                if (data[i] == \\\"'\\\") {\\r\\n                    state = STATE_QUOTED_VALUE;\\r\\n                    i += 1;\\r\\n                } else {\\r\\n                    state = STATE_UNQUOTED_VALUE;\\r\\n                }\\r\\n            } else if (state == STATE_QUOTED_VALUE) {\\r\\n                uint256 start = i;\\r\\n                uint256 valueLen = 0;\\r\\n                bool escaped = false;\\r\\n                for (; i < len; i++) {\\r\\n                    if (escaped) {\\r\\n                        data[start + valueLen] = data[i];\\r\\n                        valueLen += 1;\\r\\n                        escaped = false;\\r\\n                    } else {\\r\\n                        if (data[i] == \\\"\\\\\\\\\\\") {\\r\\n                            escaped = true;\\r\\n                        } else if (data[i] == \\\"'\\\") {\\r\\n                            return data.substring(start, valueLen);\\r\\n                        } else {\\r\\n                            data[start + valueLen] = data[i];\\r\\n                            valueLen += 1;\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            } else if (state == STATE_UNQUOTED_VALUE) {\\r\\n                uint256 start = i;\\r\\n                for (; i < len; i++) {\\r\\n                    if (data[i] == \\\" \\\") {\\r\\n                        return data.substring(start, i - start);\\r\\n                    }\\r\\n                }\\r\\n                return data.substring(start, len - start);\\r\\n            } else if (state == STATE_IGNORED_VALUE) {\\r\\n                if (data[i] == \\\"'\\\") {\\r\\n                    state = STATE_IGNORED_QUOTED_VALUE;\\r\\n                    i += 1;\\r\\n                } else {\\r\\n                    state = STATE_IGNORED_UNQUOTED_VALUE;\\r\\n                }\\r\\n            } else if (state == STATE_IGNORED_QUOTED_VALUE) {\\r\\n                bool escaped = false;\\r\\n                for (; i < len; i++) {\\r\\n                    if (escaped) {\\r\\n                        escaped = false;\\r\\n                    } else {\\r\\n                        if (data[i] == \\\"\\\\\\\\\\\") {\\r\\n                            escaped = true;\\r\\n                        } else if (data[i] == \\\"'\\\") {\\r\\n                            i += 1;\\r\\n                            while (data[i] == \\\" \\\") {\\r\\n                                i += 1;\\r\\n                            }\\r\\n                            state = STATE_START;\\r\\n                            break;\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            } else {\\r\\n                assert(state == STATE_IGNORED_UNQUOTED_VALUE);\\r\\n                for (; i < len; i++) {\\r\\n                    if (data[i] == \\\" \\\") {\\r\\n                        while (data[i] == \\\" \\\") {\\r\\n                            i += 1;\\r\\n                        }\\r\\n                        state = STATE_START;\\r\\n                        break;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return \\\"\\\";\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xfe06cdb887dbbec5530f506a979609f59accfb5497a034f1f2d73754fcf0ba05\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/IAddrResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.4;\\r\\n\\r\\n/**\\r\\n * Interface for the legacy (ETH-only) addr function.\\r\\n */\\r\\ninterface IAddrResolver {\\r\\n    event AddrChanged(bytes32 indexed node, address a);\\r\\n\\r\\n    /**\\r\\n     * Returns the address associated with an ENS node.\\r\\n     * @param node The ENS node to query.\\r\\n     * @return The associated address.\\r\\n     */\\r\\n    function addr(bytes32 node) external view returns (address payable);\\r\\n}\\r\\n\",\"keccak256\":\"0xc28e76da1c1d807c571ad75c169fa8496a8c63f21a4955171cf36b709924de20\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/IAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.4;\\r\\n\\r\\n/**\\r\\n * Interface for the new (multicoin) addr function.\\r\\n */\\r\\ninterface IAddressResolver {\\r\\n    event AddressChanged(\\r\\n        bytes32 indexed node,\\r\\n        uint256 coinType,\\r\\n        bytes newAddress\\r\\n    );\\r\\n\\r\\n    function addr(\\r\\n        bytes32 node,\\r\\n        uint256 coinType\\r\\n    ) external view returns (bytes memory);\\r\\n}\\r\\n\",\"keccak256\":\"0x5040e2be35e303880581d50dbda555dd0e5f9e11f0e818e453c3bfd8b3800b95\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/IExtendedDNSResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IExtendedDNSResolver {\\r\\n    function resolve(\\r\\n        bytes memory name,\\r\\n        bytes memory data,\\r\\n        bytes memory context\\r\\n    ) external view returns (bytes memory);\\r\\n}\\r\\n\",\"keccak256\":\"0x0cccaa04f7a79c8ce2ec6f5152fabb14be445a3de548010263bd0fd1aab32b14\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/ITextResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.4;\\r\\n\\r\\ninterface ITextResolver {\\r\\n    event TextChanged(\\r\\n        bytes32 indexed node,\\r\\n        string indexed indexedKey,\\r\\n        string key,\\r\\n        string value\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * Returns the text data associated with an ENS node and key.\\r\\n     * @param node The ENS node to query.\\r\\n     * @param key The text data key to query.\\r\\n     * @return The associated text data.\\r\\n     */\\r\\n    function text(\\r\\n        bytes32 node,\\r\\n        string calldata key\\r\\n    ) external view returns (string memory);\\r\\n}\\r\\n\",\"keccak256\":\"0x9ff1a5c32e2d5a4680027ab172651da5f9ff68129abeec02650bcc8b471b9659\",\"license\":\"MIT\"},\"contracts/utils/BytesUtils.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nlibrary BytesUtils {\\r\\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the keccak-256 hash of a byte range.\\r\\n     * @param self The byte string to hash.\\r\\n     * @param offset The position to start hashing at.\\r\\n     * @param len The number of bytes to hash.\\r\\n     * @return The hash of the byte range.\\r\\n     */\\r\\n    function keccak(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bytes32 ret) {\\r\\n        require(offset + len <= self.length);\\r\\n        assembly {\\r\\n            ret := keccak256(add(add(self, 32), offset), len)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the ENS namehash of a DNS-encoded name.\\r\\n     * @param self The DNS-encoded name to hash.\\r\\n     * @param offset The offset at which to start hashing.\\r\\n     * @return The namehash of the name.\\r\\n     */\\r\\n    function namehash(\\r\\n        bytes memory self,\\r\\n        uint256 offset\\r\\n    ) internal pure returns (bytes32) {\\r\\n        (bytes32 labelhash, uint256 newOffset) = readLabel(self, offset);\\r\\n        if (labelhash == bytes32(0)) {\\r\\n            require(offset == self.length - 1, \\\"namehash: Junk at end of name\\\");\\r\\n            return bytes32(0);\\r\\n        }\\r\\n        return\\r\\n            keccak256(abi.encodePacked(namehash(self, newOffset), labelhash));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the keccak-256 hash of a DNS-encoded label, and the offset to the start of the next label.\\r\\n     * @param self The byte string to read a label from.\\r\\n     * @param idx The index to read a label at.\\r\\n     * @return labelhash The hash of the label at the specified index, or 0 if it is the last label.\\r\\n     * @return newIdx The index of the start of the next label.\\r\\n     */\\r\\n    function readLabel(\\r\\n        bytes memory self,\\r\\n        uint256 idx\\r\\n    ) internal pure returns (bytes32 labelhash, uint256 newIdx) {\\r\\n        require(idx < self.length, \\\"readLabel: Index out of bounds\\\");\\r\\n        uint256 len = uint256(uint8(self[idx]));\\r\\n        if (len > 0) {\\r\\n            labelhash = keccak(self, idx + 1, len);\\r\\n        } else {\\r\\n            labelhash = bytes32(0);\\r\\n        }\\r\\n        newIdx = idx + len + 1;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns a positive number if `other` comes lexicographically after\\r\\n     *      `self`, a negative number if it comes before, or zero if the\\r\\n     *      contents of the two bytes are equal.\\r\\n     * @param self The first bytes to compare.\\r\\n     * @param other The second bytes to compare.\\r\\n     * @return The result of the comparison.\\r\\n     */\\r\\n    function compare(\\r\\n        bytes memory self,\\r\\n        bytes memory other\\r\\n    ) internal pure returns (int256) {\\r\\n        return compare(self, 0, self.length, other, 0, other.length);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns a positive number if `other` comes lexicographically after\\r\\n     *      `self`, a negative number if it comes before, or zero if the\\r\\n     *      contents of the two bytes are equal. Comparison is done per-rune,\\r\\n     *      on unicode codepoints.\\r\\n     * @param self The first bytes to compare.\\r\\n     * @param offset The offset of self.\\r\\n     * @param len    The length of self.\\r\\n     * @param other The second bytes to compare.\\r\\n     * @param otheroffset The offset of the other string.\\r\\n     * @param otherlen    The length of the other string.\\r\\n     * @return The result of the comparison.\\r\\n     */\\r\\n    function compare(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        uint256 len,\\r\\n        bytes memory other,\\r\\n        uint256 otheroffset,\\r\\n        uint256 otherlen\\r\\n    ) internal pure returns (int256) {\\r\\n        if (offset + len > self.length) {\\r\\n            revert OffsetOutOfBoundsError(offset + len, self.length);\\r\\n        }\\r\\n        if (otheroffset + otherlen > other.length) {\\r\\n            revert OffsetOutOfBoundsError(otheroffset + otherlen, other.length);\\r\\n        }\\r\\n\\r\\n        uint256 shortest = len;\\r\\n        if (otherlen < len) shortest = otherlen;\\r\\n\\r\\n        uint256 selfptr;\\r\\n        uint256 otherptr;\\r\\n\\r\\n        assembly {\\r\\n            selfptr := add(self, add(offset, 32))\\r\\n            otherptr := add(other, add(otheroffset, 32))\\r\\n        }\\r\\n        for (uint256 idx = 0; idx < shortest; idx += 32) {\\r\\n            uint256 a;\\r\\n            uint256 b;\\r\\n            assembly {\\r\\n                a := mload(selfptr)\\r\\n                b := mload(otherptr)\\r\\n            }\\r\\n            if (a != b) {\\r\\n                // Mask out irrelevant bytes and check again\\r\\n                uint256 mask;\\r\\n                if (shortest - idx >= 32) {\\r\\n                    mask = type(uint256).max;\\r\\n                } else {\\r\\n                    mask = ~(2 ** (8 * (idx + 32 - shortest)) - 1);\\r\\n                }\\r\\n                int256 diff = int256(a & mask) - int256(b & mask);\\r\\n                if (diff != 0) return diff;\\r\\n            }\\r\\n            selfptr += 32;\\r\\n            otherptr += 32;\\r\\n        }\\r\\n\\r\\n        return int256(len) - int256(otherlen);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns true if the two byte ranges are equal.\\r\\n     * @param self The first byte range to compare.\\r\\n     * @param offset The offset into the first byte range.\\r\\n     * @param other The second byte range to compare.\\r\\n     * @param otherOffset The offset into the second byte range.\\r\\n     * @param len The number of bytes to compare\\r\\n     * @return True if the byte ranges are equal, false otherwise.\\r\\n     */\\r\\n    function equals(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        bytes memory other,\\r\\n        uint256 otherOffset,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bool) {\\r\\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns true if the two byte ranges are equal with offsets.\\r\\n     * @param self The first byte range to compare.\\r\\n     * @param offset The offset into the first byte range.\\r\\n     * @param other The second byte range to compare.\\r\\n     * @param otherOffset The offset into the second byte range.\\r\\n     * @return True if the byte ranges are equal, false otherwise.\\r\\n     */\\r\\n    function equals(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        bytes memory other,\\r\\n        uint256 otherOffset\\r\\n    ) internal pure returns (bool) {\\r\\n        return\\r\\n            keccak(self, offset, self.length - offset) ==\\r\\n            keccak(other, otherOffset, other.length - otherOffset);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Compares a range of 'self' to all of 'other' and returns True iff\\r\\n     *      they are equal.\\r\\n     * @param self The first byte range to compare.\\r\\n     * @param offset The offset into the first byte range.\\r\\n     * @param other The second byte range to compare.\\r\\n     * @return True if the byte ranges are equal, false otherwise.\\r\\n     */\\r\\n    function equals(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        bytes memory other\\r\\n    ) internal pure returns (bool) {\\r\\n        return\\r\\n            self.length == offset + other.length &&\\r\\n            equals(self, offset, other, 0, other.length);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns true if the two byte ranges are equal.\\r\\n     * @param self The first byte range to compare.\\r\\n     * @param other The second byte range to compare.\\r\\n     * @return True if the byte ranges are equal, false otherwise.\\r\\n     */\\r\\n    function equals(\\r\\n        bytes memory self,\\r\\n        bytes memory other\\r\\n    ) internal pure returns (bool) {\\r\\n        return\\r\\n            self.length == other.length &&\\r\\n            equals(self, 0, other, 0, self.length);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 8-bit number at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 8 bits of the string, interpreted as an integer.\\r\\n     */\\r\\n    function readUint8(\\r\\n        bytes memory self,\\r\\n        uint256 idx\\r\\n    ) internal pure returns (uint8 ret) {\\r\\n        return uint8(self[idx]);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 16-bit number at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 16 bits of the string, interpreted as an integer.\\r\\n     */\\r\\n    function readUint16(\\r\\n        bytes memory self,\\r\\n        uint256 idx\\r\\n    ) internal pure returns (uint16 ret) {\\r\\n        require(idx + 2 <= self.length);\\r\\n        assembly {\\r\\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 32-bit number at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 32 bits of the string, interpreted as an integer.\\r\\n     */\\r\\n    function readUint32(\\r\\n        bytes memory self,\\r\\n        uint256 idx\\r\\n    ) internal pure returns (uint32 ret) {\\r\\n        require(idx + 4 <= self.length);\\r\\n        assembly {\\r\\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 32 byte value at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 32 bytes of the string.\\r\\n     */\\r\\n    function readBytes32(\\r\\n        bytes memory self,\\r\\n        uint256 idx\\r\\n    ) internal pure returns (bytes32 ret) {\\r\\n        require(idx + 32 <= self.length);\\r\\n        assembly {\\r\\n            ret := mload(add(add(self, 32), idx))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 32 byte value at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 32 bytes of the string.\\r\\n     */\\r\\n    function readBytes20(\\r\\n        bytes memory self,\\r\\n        uint256 idx\\r\\n    ) internal pure returns (bytes20 ret) {\\r\\n        require(idx + 20 <= self.length);\\r\\n        assembly {\\r\\n            ret := and(\\r\\n                mload(add(add(self, 32), idx)),\\r\\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the n byte value at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes.\\r\\n     * @param len The number of bytes.\\r\\n     * @return The specified 32 bytes of the string.\\r\\n     */\\r\\n    function readBytesN(\\r\\n        bytes memory self,\\r\\n        uint256 idx,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bytes32 ret) {\\r\\n        require(len <= 32);\\r\\n        require(idx + len <= self.length);\\r\\n        assembly {\\r\\n            let mask := not(sub(exp(256, sub(32, len)), 1))\\r\\n            ret := and(mload(add(add(self, 32), idx)), mask)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function memcpy(uint256 dest, uint256 src, uint256 len) private pure {\\r\\n        // Copy word-length chunks while possible\\r\\n        for (; len >= 32; len -= 32) {\\r\\n            assembly {\\r\\n                mstore(dest, mload(src))\\r\\n            }\\r\\n            dest += 32;\\r\\n            src += 32;\\r\\n        }\\r\\n\\r\\n        // Copy remaining bytes\\r\\n        unchecked {\\r\\n            uint256 mask = (256 ** (32 - len)) - 1;\\r\\n            assembly {\\r\\n                let srcpart := and(mload(src), not(mask))\\r\\n                let destpart := and(mload(dest), mask)\\r\\n                mstore(dest, or(destpart, srcpart))\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Copies a substring into a new byte string.\\r\\n     * @param self The byte string to copy from.\\r\\n     * @param offset The offset to start copying at.\\r\\n     * @param len The number of bytes to copy.\\r\\n     */\\r\\n    function substring(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        require(offset + len <= self.length);\\r\\n\\r\\n        bytes memory ret = new bytes(len);\\r\\n        uint256 dest;\\r\\n        uint256 src;\\r\\n\\r\\n        assembly {\\r\\n            dest := add(ret, 32)\\r\\n            src := add(add(self, 32), offset)\\r\\n        }\\r\\n        memcpy(dest, src, len);\\r\\n\\r\\n        return ret;\\r\\n    }\\r\\n\\r\\n    // Maps characters from 0x30 to 0x7A to their base32 values.\\r\\n    // 0xFF represents invalid characters in that range.\\r\\n    bytes constant base32HexTable =\\r\\n        hex\\\"00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\\\";\\r\\n\\r\\n    /**\\r\\n     * @dev Decodes unpadded base32 data of up to one word in length.\\r\\n     * @param self The data to decode.\\r\\n     * @param off Offset into the string to start at.\\r\\n     * @param len Number of characters to decode.\\r\\n     * @return The decoded data, left aligned.\\r\\n     */\\r\\n    function base32HexDecodeWord(\\r\\n        bytes memory self,\\r\\n        uint256 off,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bytes32) {\\r\\n        require(len <= 52);\\r\\n\\r\\n        uint256 ret = 0;\\r\\n        uint8 decoded;\\r\\n        for (uint256 i = 0; i < len; i++) {\\r\\n            bytes1 char = self[off + i];\\r\\n            require(char >= 0x30 && char <= 0x7A);\\r\\n            decoded = uint8(base32HexTable[uint256(uint8(char)) - 0x30]);\\r\\n            require(decoded <= 0x20);\\r\\n            if (i == len - 1) {\\r\\n                break;\\r\\n            }\\r\\n            ret = (ret << 5) | decoded;\\r\\n        }\\r\\n\\r\\n        uint256 bitlen = len * 5;\\r\\n        if (len % 8 == 0) {\\r\\n            // Multiple of 8 characters, no padding\\r\\n            ret = (ret << 5) | decoded;\\r\\n        } else if (len % 8 == 2) {\\r\\n            // Two extra characters - 1 byte\\r\\n            ret = (ret << 3) | (decoded >> 2);\\r\\n            bitlen -= 2;\\r\\n        } else if (len % 8 == 4) {\\r\\n            // Four extra characters - 2 bytes\\r\\n            ret = (ret << 1) | (decoded >> 4);\\r\\n            bitlen -= 4;\\r\\n        } else if (len % 8 == 5) {\\r\\n            // Five extra characters - 3 bytes\\r\\n            ret = (ret << 4) | (decoded >> 1);\\r\\n            bitlen -= 1;\\r\\n        } else if (len % 8 == 7) {\\r\\n            // Seven extra characters - 4 bytes\\r\\n            ret = (ret << 2) | (decoded >> 3);\\r\\n            bitlen -= 3;\\r\\n        } else {\\r\\n            revert();\\r\\n        }\\r\\n\\r\\n        return bytes32(ret << (256 - bitlen));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Finds the first occurrence of the byte `needle` in `self`.\\r\\n     * @param self The string to search\\r\\n     * @param off The offset to start searching at\\r\\n     * @param len The number of bytes to search\\r\\n     * @param needle The byte to search for\\r\\n     * @return The offset of `needle` in `self`, or 2**256-1 if it was not found.\\r\\n     */\\r\\n    function find(\\r\\n        bytes memory self,\\r\\n        uint256 off,\\r\\n        uint256 len,\\r\\n        bytes1 needle\\r\\n    ) internal pure returns (uint256) {\\r\\n        for (uint256 idx = off; idx < off + len; idx++) {\\r\\n            if (self[idx] == needle) {\\r\\n                return idx;\\r\\n            }\\r\\n        }\\r\\n        return type(uint256).max;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xdeb9ab55906bbae2e14dd91f16acba3ab2b5b3518507d9aebc8a7fba72221308\",\"license\":\"MIT\"},\"contracts/utils/HexUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nlibrary HexUtils {\\r\\n    /**\\r\\n     * @dev Attempts to parse bytes32 from a hex string\\r\\n     * @param str The string to parse\\r\\n     * @param idx The offset to start parsing at\\r\\n     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\\r\\n     */\\r\\n    function hexStringToBytes32(\\r\\n        bytes memory str,\\r\\n        uint256 idx,\\r\\n        uint256 lastIdx\\r\\n    ) internal pure returns (bytes32, bool) {\\r\\n        require(lastIdx - idx <= 64);\\r\\n        (bytes memory r, bool valid) = hexToBytes(str, idx, lastIdx);\\r\\n        if (!valid) {\\r\\n            return (bytes32(0), false);\\r\\n        }\\r\\n        bytes32 ret;\\r\\n        assembly {\\r\\n            ret := shr(mul(4, sub(64, sub(lastIdx, idx))), mload(add(r, 32)))\\r\\n        }\\r\\n        return (ret, true);\\r\\n    }\\r\\n\\r\\n    function hexToBytes(\\r\\n        bytes memory str,\\r\\n        uint256 idx,\\r\\n        uint256 lastIdx\\r\\n    ) internal pure returns (bytes memory r, bool valid) {\\r\\n        uint256 hexLength = lastIdx - idx;\\r\\n        if (hexLength % 2 == 1) {\\r\\n            revert(\\\"Invalid string length\\\");\\r\\n        }\\r\\n        r = new bytes(hexLength / 2);\\r\\n        valid = true;\\r\\n        assembly {\\r\\n            // check that the index to read to is not past the end of the string\\r\\n            if gt(lastIdx, mload(str)) {\\r\\n                revert(0, 0)\\r\\n            }\\r\\n\\r\\n            function getHex(c) -> ascii {\\r\\n                // chars 48-57: 0-9\\r\\n                if and(gt(c, 47), lt(c, 58)) {\\r\\n                    ascii := sub(c, 48)\\r\\n                    leave\\r\\n                }\\r\\n                // chars 65-70: A-F\\r\\n                if and(gt(c, 64), lt(c, 71)) {\\r\\n                    ascii := add(sub(c, 65), 10)\\r\\n                    leave\\r\\n                }\\r\\n                // chars 97-102: a-f\\r\\n                if and(gt(c, 96), lt(c, 103)) {\\r\\n                    ascii := add(sub(c, 97), 10)\\r\\n                    leave\\r\\n                }\\r\\n                // invalid char\\r\\n                ascii := 0xff\\r\\n            }\\r\\n\\r\\n            let ptr := add(str, 32)\\r\\n            for {\\r\\n                let i := idx\\r\\n            } lt(i, lastIdx) {\\r\\n                i := add(i, 2)\\r\\n            } {\\r\\n                let byte1 := getHex(byte(0, mload(add(ptr, i))))\\r\\n                let byte2 := getHex(byte(0, mload(add(ptr, add(i, 1)))))\\r\\n                // if either byte is invalid, set invalid and break loop\\r\\n                if or(eq(byte1, 0xff), eq(byte2, 0xff)) {\\r\\n                    valid := false\\r\\n                    break\\r\\n                }\\r\\n                let combined := or(shl(4, byte1), byte2)\\r\\n                mstore8(add(add(r, 32), div(sub(i, idx), 2)), combined)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Attempts to parse an address from a hex string\\r\\n     * @param str The string to parse\\r\\n     * @param idx The offset to start parsing at\\r\\n     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\\r\\n     */\\r\\n    function hexToAddress(\\r\\n        bytes memory str,\\r\\n        uint256 idx,\\r\\n        uint256 lastIdx\\r\\n    ) internal pure returns (address, bool) {\\r\\n        if (lastIdx - idx < 40) return (address(0x0), false);\\r\\n        (bytes32 r, bool valid) = hexStringToBytes32(str, idx, lastIdx);\\r\\n        return (address(uint160(uint256(r))), valid);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Attempts to convert an address to a hex string\\r\\n     * @param addr The _addr to parse\\r\\n     */\\r\\n    function addressToHex(address addr) internal pure returns (string memory) {\\r\\n        bytes memory hexString = new bytes(40);\\r\\n        for (uint i = 0; i < 20; i++) {\\r\\n            bytes1 byteValue = bytes1(uint8(uint160(addr) >> (8 * (19 - i))));\\r\\n            bytes1 highNibble = bytes1(uint8(byteValue) / 16);\\r\\n            bytes1 lowNibble = bytes1(\\r\\n                uint8(byteValue) - 16 * uint8(highNibble)\\r\\n            );\\r\\n            hexString[2 * i] = _nibbleToHexChar(highNibble);\\r\\n            hexString[2 * i + 1] = _nibbleToHexChar(lowNibble);\\r\\n        }\\r\\n        return string(hexString);\\r\\n    }\\r\\n\\r\\n    function _nibbleToHexChar(\\r\\n        bytes1 nibble\\r\\n    ) internal pure returns (bytes1 hexChar) {\\r\\n        if (uint8(nibble) < 10) return bytes1(uint8(nibble) + 0x30);\\r\\n        else return bytes1(uint8(nibble) + 0x57);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xaed394476f74cf1e4f56ce997910e3a8002f35b338714224eee2ba6c628745ed\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50611265806100206000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c806301ffc9a71461003b5780638ef98a7e14610074575b600080fd5b61005f610049366004610e2e565b6001600160e01b03191663477cc53f60e11b1490565b60405190151581526020015b60405180910390f35b610087610082366004610ea8565b610094565b60405161006b9190610f66565b606060006100a28587610f99565b9050636262541160e11b6001600160e01b03198216016100ce576100c68484610139565b91505061012f565b63071a40fd60e11b6001600160e01b03198216016100f2576100c686868686610222565b63298b8af160e21b6001600160e01b0319821601610116576100c6868686866103a1565b60405163d623472560e01b815260040160405180910390fd5b9695505050505050565b6060600061019a84848080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050604080518082019091526006815265615b36305d3d60d01b6020820152915061043c9050565b905080516000036101ac57905061021c565b6000806101c660028451856109ed9092919063ffffffff16565b91509150806101f35782604051630f79e00960e21b81526004016101ea9190610f66565b60405180910390fd5b604080516001600160a01b03841660208201520160405160208183030381529060405293505050505b92915050565b606060006102338560048189610fc9565b8101906102409190610ff3565b9150506060816380000000166000146102c7576102c085858080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061029c92505050637fffffff8516610a2b565b6040516020016102ac9190611015565b60405160208183030381529060405261043c565b905061031f565b61031c85858080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061030c9250869150610a2b9050565b6040516020016102ac919061104c565b90505b80516000036103315791506103999050565b60008061034b60028451856109ed9092919063ffffffff16565b915091508061036f5782604051630f79e00960e21b81526004016101ea9190610f66565b604080516001600160a01b0384166020820152016040516020818303038152906040529450505050505b949350505050565b606060006103b28560048189610fc9565b8101906103bf9190611098565b915050600061040e85858080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250506040516102ac9250869150602001611153565b9050806040516020016104219190610f66565b60405160208183030381529060405292505050949350505050565b8151606090600090815b818110156109d4578261048c57845161046790879083908890600090610b2c565b156104835784516104789082611186565b905060039250610446565b60019250610446565b6001830361052f575b8181101561052a578581815181106104af576104af611199565b01602001516001600160f81b031916603d60f81b036104de57600692506104d7600182611186565b9050610446565b8581815181106104f0576104f0611199565b01602001516001600160f81b031916605b60f81b0361051857600292506104d7600182611186565b80610522816111af565b915050610495565b610446565b600283036105c4575b8181101561052a5785818151811061055257610552611199565b01602001516001600160f81b031916605d60f81b036105b2576006925061057a600182611186565b905085818151811061058e5761058e611199565b01602001516001600160f81b031916603d60f81b0361052a576104d7600182611186565b806105bc816111af565b915050610538565b6003830361060f578581815181106105de576105de611199565b01602001516001600160f81b031916602760f81b0361060657600492506104d7600182611186565b60059250610446565b6004830361078457806000805b8484101561077c5780156106935788848151811061063c5761063c611199565b01602001516001600160f81b031916896106568486611186565b8151811061066657610666611199565b60200101906001600160f81b031916908160001a905350610688600183611186565b91506000905061076a565b8884815181106106a5576106a5611199565b01602001516001600160f81b031916601760fa1b036106c65750600161076a565b8884815181106106d8576106d8611199565b01602001516001600160f81b031916602760f81b03610709576106fc898484610b4f565b965050505050505061021c565b88848151811061071b5761071b611199565b01602001516001600160f81b031916896107358486611186565b8151811061074557610745611199565b60200101906001600160f81b031916908160001a905350610767600183611186565b91505b83610774816111af565b94505061061c565b505050610446565b6005830361080257805b828210156107f4578682815181106107a8576107a8611199565b01602001516001600160f81b031916600160fd1b036107e2576107d7816107cf81856111c8565b899190610b4f565b94505050505061021c565b816107ec816111af565b92505061078e565b6107d7816107cf81866111c8565b6006830361084d5785818151811061081c5761081c611199565b01602001516001600160f81b031916602760f81b0361084457600792506104d7600182611186565b60089250610446565b600783036109385760005b8282101561093257801561086e57506000610920565b86828151811061088057610880611199565b01602001516001600160f81b031916601760fa1b036108a157506001610920565b8682815181106108b3576108b3611199565b01602001516001600160f81b031916602760f81b03610920576108d7600183611186565b91505b8682815181106108ec576108ec611199565b01602001516001600160f81b031916600160fd1b0361091757610910600183611186565b91506108da565b60009350610932565b8161092a816111af565b925050610858565b50610446565b60088314610948576109486111db565b8181101561052a5785818151811061096257610962611199565b01602001516001600160f81b031916600160fd1b036109c2575b85818151811061098e5761098e611199565b01602001516001600160f81b031916600160fd1b036109b9576109b2600182611186565b905061097c565b60009250610446565b806109cc816111af565b915050610948565b5050604080516020810190915260008152949350505050565b60008060286109fc85856111c8565b1015610a0d57506000905080610a23565b600080610a1b878787610bd1565b909450925050505b935093915050565b606081600003610a525750506040805180820190915260018152600360fc1b602082015290565b8160005b8115610a7c5780610a66816111af565b9150610a759050600a83611207565b9150610a56565b60008167ffffffffffffffff811115610a9757610a97611082565b6040519080825280601f01601f191660200182016040528015610ac1576020820181803683370190505b5090505b841561039957610ad66001836111c8565b9150610ae3600a8661121b565b610aee906030611186565b60f81b818381518110610b0357610b03611199565b60200101906001600160f81b031916908160001a905350610b25600a86611207565b9450610ac5565b6000610b39848484610c2e565b610b44878785610c2e565b149695505050505050565b8251606090610b5e8385611186565b1115610b6957600080fd5b60008267ffffffffffffffff811115610b8457610b84611082565b6040519080825280601f01601f191660200182016040528015610bae576020820181803683370190505b50905060208082019086860101610bc6828287610c52565b509095945050505050565b6000806040610be085856111c8565b1115610beb57600080fd5b600080610bf9878787610ca8565b9150915080610c11575060009250829150610a239050565b50602001516004858503604003021c915060019050935093915050565b8251600090610c3d8385611186565b1115610c4857600080fd5b5091016020012090565b60208110610c8a5781518352610c69602084611186565b9250610c76602083611186565b9150610c836020826111c8565b9050610c52565b905182516020929092036101000a6000190180199091169116179052565b6060600080610cb785856111c8565b9050610cc460028261121b565b600103610d0b5760405162461bcd60e51b8152602060048201526015602482015274092dcecc2d8d2c840e6e8e4d2dcce40d8cadccee8d605b1b60448201526064016101ea565b610d16600282611207565b67ffffffffffffffff811115610d2e57610d2e611082565b6040519080825280601f01601f191660200182016040528015610d58576020820181803683370190505b509250600191508551841115610d6d57600080fd5b610dbe565b6000603a8210602f83111615610d8a5750602f190190565b60478210604083111615610da057506036190190565b60678210606083111615610db657506056190190565b5060ff919050565b60208601855b85811015610e2357610ddb8183015160001a610d72565b610ded6001830184015160001a610d72565b60ff811460ff83141715610e0657600095505050610e23565b60049190911b178060028984030487016020015350600201610dc4565b505050935093915050565b600060208284031215610e4057600080fd5b81356001600160e01b031981168114610e5857600080fd5b9392505050565b60008083601f840112610e7157600080fd5b50813567ffffffffffffffff811115610e8957600080fd5b602083019150836020828501011115610ea157600080fd5b9250929050565b60008060008060008060608789031215610ec157600080fd5b863567ffffffffffffffff80821115610ed957600080fd5b610ee58a838b01610e5f565b90985096506020890135915080821115610efe57600080fd5b610f0a8a838b01610e5f565b90965094506040890135915080821115610f2357600080fd5b50610f3089828a01610e5f565b979a9699509497509295939492505050565b60005b83811015610f5d578181015183820152602001610f45565b50506000910152565b6020815260008251806020840152610f85816040850160208701610f42565b601f01601f19169190910160400192915050565b6001600160e01b03198135818116916004851015610fc15780818660040360031b1b83161692505b505092915050565b60008085851115610fd957600080fd5b83861115610fe657600080fd5b5050820193919092039150565b6000806040838503121561100657600080fd5b50508035926020909101359150565b62615b6560e81b815260008251611033816003850160208701610f42565b615d3d60f01b6003939091019283015250600501919050565b61615b60f01b815260008251611069816002850160208701610f42565b615d3d60f01b6002939091019283015250600401919050565b634e487b7160e01b600052604160045260246000fd5b600080604083850312156110ab57600080fd5b82359150602083013567ffffffffffffffff808211156110ca57600080fd5b818501915085601f8301126110de57600080fd5b8135818111156110f0576110f0611082565b604051601f8201601f19908116603f0116810190838211818310171561111857611118611082565b8160405282815288602084870101111561113157600080fd5b8260208601602083013760006020848301015280955050505050509250929050565b61745b60f01b815260008251611069816002850160208701610f42565b634e487b7160e01b600052601160045260246000fd5b8082018082111561021c5761021c611170565b634e487b7160e01b600052603260045260246000fd5b6000600182016111c1576111c1611170565b5060010190565b8181038181111561021c5761021c611170565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601260045260246000fd5b600082611216576112166111f1565b500490565b60008261122a5761122a6111f1565b50069056fea2646970667358221220f27898ae50c950b7972a3d67b452b02369ae6fe6e17b95110762ee61ada2d62764736f6c63430008140033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c806301ffc9a71461003b5780638ef98a7e14610074575b600080fd5b61005f610049366004610e2e565b6001600160e01b03191663477cc53f60e11b1490565b60405190151581526020015b60405180910390f35b610087610082366004610ea8565b610094565b60405161006b9190610f66565b606060006100a28587610f99565b9050636262541160e11b6001600160e01b03198216016100ce576100c68484610139565b91505061012f565b63071a40fd60e11b6001600160e01b03198216016100f2576100c686868686610222565b63298b8af160e21b6001600160e01b0319821601610116576100c6868686866103a1565b60405163d623472560e01b815260040160405180910390fd5b9695505050505050565b6060600061019a84848080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050604080518082019091526006815265615b36305d3d60d01b6020820152915061043c9050565b905080516000036101ac57905061021c565b6000806101c660028451856109ed9092919063ffffffff16565b91509150806101f35782604051630f79e00960e21b81526004016101ea9190610f66565b60405180910390fd5b604080516001600160a01b03841660208201520160405160208183030381529060405293505050505b92915050565b606060006102338560048189610fc9565b8101906102409190610ff3565b9150506060816380000000166000146102c7576102c085858080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061029c92505050637fffffff8516610a2b565b6040516020016102ac9190611015565b60405160208183030381529060405261043c565b905061031f565b61031c85858080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061030c9250869150610a2b9050565b6040516020016102ac919061104c565b90505b80516000036103315791506103999050565b60008061034b60028451856109ed9092919063ffffffff16565b915091508061036f5782604051630f79e00960e21b81526004016101ea9190610f66565b604080516001600160a01b0384166020820152016040516020818303038152906040529450505050505b949350505050565b606060006103b28560048189610fc9565b8101906103bf9190611098565b915050600061040e85858080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250506040516102ac9250869150602001611153565b9050806040516020016104219190610f66565b60405160208183030381529060405292505050949350505050565b8151606090600090815b818110156109d4578261048c57845161046790879083908890600090610b2c565b156104835784516104789082611186565b905060039250610446565b60019250610446565b6001830361052f575b8181101561052a578581815181106104af576104af611199565b01602001516001600160f81b031916603d60f81b036104de57600692506104d7600182611186565b9050610446565b8581815181106104f0576104f0611199565b01602001516001600160f81b031916605b60f81b0361051857600292506104d7600182611186565b80610522816111af565b915050610495565b610446565b600283036105c4575b8181101561052a5785818151811061055257610552611199565b01602001516001600160f81b031916605d60f81b036105b2576006925061057a600182611186565b905085818151811061058e5761058e611199565b01602001516001600160f81b031916603d60f81b0361052a576104d7600182611186565b806105bc816111af565b915050610538565b6003830361060f578581815181106105de576105de611199565b01602001516001600160f81b031916602760f81b0361060657600492506104d7600182611186565b60059250610446565b6004830361078457806000805b8484101561077c5780156106935788848151811061063c5761063c611199565b01602001516001600160f81b031916896106568486611186565b8151811061066657610666611199565b60200101906001600160f81b031916908160001a905350610688600183611186565b91506000905061076a565b8884815181106106a5576106a5611199565b01602001516001600160f81b031916601760fa1b036106c65750600161076a565b8884815181106106d8576106d8611199565b01602001516001600160f81b031916602760f81b03610709576106fc898484610b4f565b965050505050505061021c565b88848151811061071b5761071b611199565b01602001516001600160f81b031916896107358486611186565b8151811061074557610745611199565b60200101906001600160f81b031916908160001a905350610767600183611186565b91505b83610774816111af565b94505061061c565b505050610446565b6005830361080257805b828210156107f4578682815181106107a8576107a8611199565b01602001516001600160f81b031916600160fd1b036107e2576107d7816107cf81856111c8565b899190610b4f565b94505050505061021c565b816107ec816111af565b92505061078e565b6107d7816107cf81866111c8565b6006830361084d5785818151811061081c5761081c611199565b01602001516001600160f81b031916602760f81b0361084457600792506104d7600182611186565b60089250610446565b600783036109385760005b8282101561093257801561086e57506000610920565b86828151811061088057610880611199565b01602001516001600160f81b031916601760fa1b036108a157506001610920565b8682815181106108b3576108b3611199565b01602001516001600160f81b031916602760f81b03610920576108d7600183611186565b91505b8682815181106108ec576108ec611199565b01602001516001600160f81b031916600160fd1b0361091757610910600183611186565b91506108da565b60009350610932565b8161092a816111af565b925050610858565b50610446565b60088314610948576109486111db565b8181101561052a5785818151811061096257610962611199565b01602001516001600160f81b031916600160fd1b036109c2575b85818151811061098e5761098e611199565b01602001516001600160f81b031916600160fd1b036109b9576109b2600182611186565b905061097c565b60009250610446565b806109cc816111af565b915050610948565b5050604080516020810190915260008152949350505050565b60008060286109fc85856111c8565b1015610a0d57506000905080610a23565b600080610a1b878787610bd1565b909450925050505b935093915050565b606081600003610a525750506040805180820190915260018152600360fc1b602082015290565b8160005b8115610a7c5780610a66816111af565b9150610a759050600a83611207565b9150610a56565b60008167ffffffffffffffff811115610a9757610a97611082565b6040519080825280601f01601f191660200182016040528015610ac1576020820181803683370190505b5090505b841561039957610ad66001836111c8565b9150610ae3600a8661121b565b610aee906030611186565b60f81b818381518110610b0357610b03611199565b60200101906001600160f81b031916908160001a905350610b25600a86611207565b9450610ac5565b6000610b39848484610c2e565b610b44878785610c2e565b149695505050505050565b8251606090610b5e8385611186565b1115610b6957600080fd5b60008267ffffffffffffffff811115610b8457610b84611082565b6040519080825280601f01601f191660200182016040528015610bae576020820181803683370190505b50905060208082019086860101610bc6828287610c52565b509095945050505050565b6000806040610be085856111c8565b1115610beb57600080fd5b600080610bf9878787610ca8565b9150915080610c11575060009250829150610a239050565b50602001516004858503604003021c915060019050935093915050565b8251600090610c3d8385611186565b1115610c4857600080fd5b5091016020012090565b60208110610c8a5781518352610c69602084611186565b9250610c76602083611186565b9150610c836020826111c8565b9050610c52565b905182516020929092036101000a6000190180199091169116179052565b6060600080610cb785856111c8565b9050610cc460028261121b565b600103610d0b5760405162461bcd60e51b8152602060048201526015602482015274092dcecc2d8d2c840e6e8e4d2dcce40d8cadccee8d605b1b60448201526064016101ea565b610d16600282611207565b67ffffffffffffffff811115610d2e57610d2e611082565b6040519080825280601f01601f191660200182016040528015610d58576020820181803683370190505b509250600191508551841115610d6d57600080fd5b610dbe565b6000603a8210602f83111615610d8a5750602f190190565b60478210604083111615610da057506036190190565b60678210606083111615610db657506056190190565b5060ff919050565b60208601855b85811015610e2357610ddb8183015160001a610d72565b610ded6001830184015160001a610d72565b60ff811460ff83141715610e0657600095505050610e23565b60049190911b178060028984030487016020015350600201610dc4565b505050935093915050565b600060208284031215610e4057600080fd5b81356001600160e01b031981168114610e5857600080fd5b9392505050565b60008083601f840112610e7157600080fd5b50813567ffffffffffffffff811115610e8957600080fd5b602083019150836020828501011115610ea157600080fd5b9250929050565b60008060008060008060608789031215610ec157600080fd5b863567ffffffffffffffff80821115610ed957600080fd5b610ee58a838b01610e5f565b90985096506020890135915080821115610efe57600080fd5b610f0a8a838b01610e5f565b90965094506040890135915080821115610f2357600080fd5b50610f3089828a01610e5f565b979a9699509497509295939492505050565b60005b83811015610f5d578181015183820152602001610f45565b50506000910152565b6020815260008251806020840152610f85816040850160208701610f42565b601f01601f19169190910160400192915050565b6001600160e01b03198135818116916004851015610fc15780818660040360031b1b83161692505b505092915050565b60008085851115610fd957600080fd5b83861115610fe657600080fd5b5050820193919092039150565b6000806040838503121561100657600080fd5b50508035926020909101359150565b62615b6560e81b815260008251611033816003850160208701610f42565b615d3d60f01b6003939091019283015250600501919050565b61615b60f01b815260008251611069816002850160208701610f42565b615d3d60f01b6002939091019283015250600401919050565b634e487b7160e01b600052604160045260246000fd5b600080604083850312156110ab57600080fd5b82359150602083013567ffffffffffffffff808211156110ca57600080fd5b818501915085601f8301126110de57600080fd5b8135818111156110f0576110f0611082565b604051601f8201601f19908116603f0116810190838211818310171561111857611118611082565b8160405282815288602084870101111561113157600080fd5b8260208601602083013760006020848301015280955050505050509250929050565b61745b60f01b815260008251611069816002850160208701610f42565b634e487b7160e01b600052601160045260246000fd5b8082018082111561021c5761021c611170565b634e487b7160e01b600052603260045260246000fd5b6000600182016111c1576111c1611170565b5060010190565b8181038181111561021c5761021c611170565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601260045260246000fd5b600082611216576112166111f1565b500490565b60008261122a5761122a6111f1565b50069056fea2646970667358221220f27898ae50c950b7972a3d67b452b02369ae6fe6e17b95110762ee61ada2d62764736f6c63430008140033",
  "devdoc": {
    "details": "Resolves names on ENS by interpreting record data stored in a DNS TXT record.      This resolver implements the IExtendedDNSResolver interface, meaning that when      a DNS name specifies it as the resolver via a TXT record, this resolver's      resolve() method is invoked, and is passed any additional information from that      text record. This resolver implements a simple text parser allowing a variety      of records to be specified in text, which will then be used to resolve the name      in ENS.      To use this, set a TXT record on your DNS name in the following format:          ENS1 <address or name of ExtendedDNSResolver> <record data>      For example:          ENS1 2.dnsname.ens.eth a[60]=0x1234...      The record data consists of a series of key=value pairs, separated by spaces. Keys      may have an optional argument in square brackets, and values may be either unquoted       - in which case they may not contain spaces - or single-quoted. Single quotes in      a quoted value may be backslash-escaped.                                                                                         \" \"                                                                                                                                ^key\"[\"arg\"]\"\"=\"\"'\"quoted_value\"'\"$                                                                                                                                      unquoted_value                                                                      Record types:       - a[<coinType>] - Specifies how an `addr()` request should be resolved for the specified         `coinType`. Ethereum has `coinType` 60. The value must be 0x-prefixed hexadecimal, and will         be returned unmodified; this means that non-EVM addresses will need to be translated         into binary format and then encoded in hex.         Examples:          - a[60]=0xFe89cc7aBB2C4183683ab71653C4cdc9B02D44b7          - a[0]=0x00149010587f8364b964fcaa70687216b53bd2cbd798       - a[e<chainId>] - Specifies how an `addr()` request should be resolved for the specified         `chainId`. The value must be 0x-prefixed hexadecimal. When encoding an address for an         EVM-based cryptocurrency that uses a chainId instead of a coinType, this syntax *must*         be used in place of the coin type - eg, Optimism is `a[e10]`, not `a[2147483658]`.         A list of supported cryptocurrencies for both syntaxes can be found here:           https://github.com/ensdomains/address-encoder/blob/master/docs/supported-cryptocurrencies.md         Example:          - a[e10]=0xFe89cc7aBB2C4183683ab71653C4cdc9B02D44b7       - t[<key>] - Specifies how a `text()` request should be resolved for the specified `key`.         Examples:          - t[com.twitter]=nicksdjohnson          - t[url]='https://ens.domains/'          - t[note]='I\\'m great'",
    "kind": "dev",
    "methods": {
      "supportsInterface(bytes4)": {
        "details": "Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}