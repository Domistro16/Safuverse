{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n        } else if (signature.length == 64) {\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let vs := mload(add(signature, 0x40))\n                r := mload(add(signature, 0x20))\n                s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n                v := add(shr(255, vs), 27)\n            }\n        } else {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/wallet/interfaces/IAccount.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * User Operation struct\r\n * @param sender the sender account of this request.\r\n * @param nonce unique value the sender uses to prevent replay attacks.\r\n * @param initCode if set, the account contract will be created by this constructor.\r\n * @param callData the method call to execute on this account.\r\n * @param accountGasLimits packed gas limits for validation and execution.\r\n * @param preVerificationGas gas not calculated by the handleOps method, but added to the fee.\r\n * @param gasFees packed gas fees (maxPriorityFeePerGas, maxFeePerGas).\r\n * @param paymasterAndData strictly for the Paymaster to use.\r\n * @param signature sender-verified signature to be used by the account.\r\n */\r\nstruct PackedUserOperation {\r\n    address sender;\r\n    uint256 nonce;\r\n    bytes initCode;\r\n    bytes callData;\r\n    bytes32 accountGasLimits;\r\n    uint256 preVerificationGas;\r\n    bytes32 gasFees;\r\n    bytes paymasterAndData;\r\n    bytes signature;\r\n}\r\n\r\ninterface IAccount {\r\n    /**\r\n     * Validate user's signature and nonce\r\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\r\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\r\n     * This allows making a \"simulation call\" without a valid signature\r\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\r\n     *\r\n     * @dev Must validate caller is the entryPoint.\r\n     *      Must validate the signature and nonce.\r\n     * @param userOp the operation that is about to be executed.\r\n     * @param userOpHash hash of the user's request data. can be used as the basis for signature.\r\n     * @param missingAccountFunds missing funds on the account's deposit in the entrypoint.\r\n     *      This is the minimum amount to transfer to the sender(entryPoint) to be able to make the call.\r\n     *      The excess is left as a deposit in the entrypoint, for future calls.\r\n     *      can be withdrawn anytime using \"withdrawTo\"\r\n     *      In case there is a paymaster in the request (or the current deposit is high enough), this value will be zero.\r\n     * @return validationData packed validation data.\r\n     *      <20-byte> aggregator - 0 for sig validation\r\n     *      <6-byte> validUntil - 0 for indefinite\r\n     *      <6-byte> validAfter - 0 for immediate\r\n     */\r\n    function validateUserOp(\r\n        PackedUserOperation calldata userOp,\r\n        bytes32 userOpHash,\r\n        uint256 missingAccountFunds\r\n    ) external returns (uint256 validationData);\r\n}\r\n"
    },
    "contracts/wallet/SimpleAgentAccount.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\r\nimport {IAccount, PackedUserOperation} from \"./interfaces/IAccount.sol\";\r\n\r\n/**\r\n * @title SimpleAgentAccount\r\n * @notice Minimal ERC-4337 compatible smart wallet for AI agents\r\n * @dev Deployed behind ERC1967Proxy via AgentAccountFactory.\r\n *      Updated for EntryPoint v0.7 (PackedUserOperation).\r\n */\r\ncontract SimpleAgentAccount is IAccount {\r\n    using ECDSA for bytes32;\r\n\r\n    address public owner;\r\n    address public entryPoint;\r\n    bool private _initialized;\r\n\r\n    event SimpleAgentAccountInitialized(\r\n        address indexed owner,\r\n        address indexed entryPoint\r\n    );\r\n    event Executed(address indexed target, uint256 value, bytes data);\r\n\r\n    modifier onlyOwnerOrEntryPoint() {\r\n        require(\r\n            msg.sender == owner || msg.sender == entryPoint,\r\n            \"Only owner or EntryPoint\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        _;\r\n    }\r\n\r\n    function initialize(address _owner, address _entryPoint) external {\r\n        require(!_initialized, \"Already initialized\");\r\n        _initialized = true;\r\n        owner = _owner;\r\n        entryPoint = _entryPoint;\r\n        emit SimpleAgentAccountInitialized(_owner, _entryPoint);\r\n    }\r\n\r\n    /**\r\n     * @notice Execute a call from this account\r\n     */\r\n    function execute(\r\n        address dest,\r\n        uint256 value,\r\n        bytes calldata func\r\n    ) external onlyOwnerOrEntryPoint {\r\n        _call(dest, value, func);\r\n    }\r\n\r\n    /**\r\n     * @notice Execute a batch of calls\r\n     */\r\n    function executeBatch(\r\n        address[] calldata dest,\r\n        uint256[] calldata values,\r\n        bytes[] calldata funcs\r\n    ) external onlyOwnerOrEntryPoint {\r\n        require(\r\n            dest.length == funcs.length && dest.length == values.length,\r\n            \"Length mismatch\"\r\n        );\r\n        for (uint256 i = 0; i < dest.length; i++) {\r\n            _call(dest[i], values[i], funcs[i]);\r\n        }\r\n    }\r\n\r\n    function _call(address target, uint256 value, bytes memory data) internal {\r\n        (bool success, bytes memory result) = target.call{value: value}(data);\r\n        if (!success) {\r\n            assembly {\r\n                revert(add(result, 32), mload(result))\r\n            }\r\n        }\r\n        emit Executed(target, value, data);\r\n    }\r\n\r\n    /**\r\n     * @notice ERC-4337 v0.7 validateUserOp\r\n     */\r\n    function validateUserOp(\r\n        PackedUserOperation calldata userOp,\r\n        bytes32 userOpHash,\r\n        uint256 missingAccountFunds\r\n    ) external override returns (uint256 validationData) {\r\n        require(msg.sender == entryPoint, \"Only EntryPoint\");\r\n\r\n        bytes32 hash = keccak256(\r\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", userOpHash)\r\n        );\r\n        address recovered = hash.recover(userOp.signature);\r\n\r\n        if (recovered != owner) {\r\n            return 1; // SIG_VALIDATION_FAILED\r\n        }\r\n\r\n        if (missingAccountFunds > 0) {\r\n            (bool success, ) = payable(entryPoint).call{\r\n                value: missingAccountFunds\r\n            }(\"\");\r\n            require(success, \"Failed to prefund\");\r\n        }\r\n\r\n        return 0; // SIG_VALIDATION_SUCCESS\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer ownership\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"Zero address\");\r\n        owner = newOwner;\r\n    }\r\n\r\n    receive() external payable {}\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "metadata",
          "evm.methodIdentifiers",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "evmVersion": "paris",
    "metadata": {
      "useLiteralContent": true
    }
  }
}